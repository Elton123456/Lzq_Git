# 第一次讨论问题整理汇总
##01讲
一条SQL语句的执行过程：经过连接器->分析器->优化器->执行器->存储引擎。
MySQL基本架构主要了解如下功能即可：
分析器：词法分析，语法分析
优化器：执行计划生成，索引选择
执行器：操作引擎，返回结果
*查询缓存：对于SELECT语句，在解析查询前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。（即短路返回，一般线上不开启，性能会下降） 8版本以后无次功能 [[线上要不要开启查询缓存](https://www.aikaiyuan.com/8702.html "线上要不要开启查询缓存")]*

###MySQL两大引擎的区别
Innodb引擎
>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表

MyIASM引擎
> 在5.5.5版本之前MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。该引擎采用的表级锁，如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

两大引擎主要区别

| MyIASM引擎       | Innodb引擎                        |
| ---------------- | --------------------------------- |
| 非事务安全       | 事务安全                          |
| 粒度是表级的     | 支持行级锁                        |
| 支持全文类型索引 | 支持全文类型索引(1.2.x版本后支持) |

##02讲
redo log是InnoDB引擎特有的日志，可以保证InnoDB在数据库发生异常重启后，之前提交的记录不会丢失（crash-safe）。
binlog是Server层特有的日志。binlog有两种模式，statement格式记录sql语句，row格式记录行的内容（两条，包括更新前和更新后）

**binlog格式**

| statement | row                  | mixed                                                        |
| --------- | -------------------- | ------------------------------------------------------------ |
| SQL语句   | 记录表中每个字段的值 | 默认使用statement模式，判断会出现数据不一致的情况时，采用row模式 |

**redo log和binlog区别**

| redo log                   | binlog                       |
| -------------------------- | ---------------------------- |
| InnoDB特有                 | 所有引擎都可以使用           |
| 物理日志（记录做了的修改） | 逻辑日志（记录做修改的步骤） |
| 循环写，空间固定会用完     | 追加写，不会覆盖之前的内容   |

##03讲
**事务隔离级别**
+ 读未提交：（都不可避免）在一个事务中，读取其他事务未提交的数据，其他事务回滚后，导致读的数据与数据库中的数据不一致。
+ 读已提交：（可避免脏读，提交读，可以立即读到其他事务提交的数据）：一个事务从开始直接提交之前，所做的任何修改对其他事务都是不可见的。
+ 可重复读（可避免脏读、不可重复读，快照读，一致性读）：一个事务中多次读取相同的记录，结果是一致的。

一句话总结读已提交RC和可重复读的区别RR：
RC：别人改数据的事务已经提交，我在我的事务中才能读到。
RR：别人该数据的事务已经提交，我在我的事务中也不去读。