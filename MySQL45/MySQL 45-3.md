# MySQL 45-3

### 事务

事务支持是在引擎层实现的。

### ACID（事务特征）

Atomicity、Consistency、Isolation、Durability

即原子性、一致性、隔离性、持久性

__多事务执行时，可能出现脏读、不可重复读、幻读，为了解决该类问题，引入隔离级别。__

脏读(dirty read)：一个事务中访问到了另一个事务未提交的数据。

不可重复读(non-repeatable read)：一个事务中读取同一条记录两次，得到的结果不一致。

幻读(phantom read)：一个事务读取两次，得到的记录条数不一致。

### 隔离级别

读未提交(read uncommitted)：一个事务还未提交，它所做的变更就能被别的事务看到。

读提交(read committed)：一个事务提交之后，它做的变更才会被其它事务看到。

可重复读(repeatable read)：一个事务执行过程中看到的数据，总是和这个事务启动时看到的数据一致。

串行化(serializable)：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当读写锁冲突时，后访问的事务须等前一个事务执行完成，才能继续执行。

_注：Oracle数据库默认隔离级别为“读提交”，因此，对于从Oracle迁移到MySQL 的应用，为保证数据库隔离级别的一致，需将MySQL的隔离级别设置为“读提交”_



__为什么不建议使用长事务__

An:长事务意味着系统里会存在很老的事务视图，由于这些事务随时可能访问数据库中的任何数据，所以这个事务提交前，数据库中它可能用到的回滚记录均需保留，会导致大量占用空间。



__事务的启动方式__

An:

1、显示启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback。

2、set autocommit=0，这个命令会将这个线程的自动提交关掉。即，如果只执行一个select语句，这个事务就启动了，且不会自动提交。该事务将持续存在到主动执行commit或rollback语句，或者断开连接。

因此，建议总是使用set autocommit=1，通过显示语句的方式来启动事务。

_但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。_

_在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。_



