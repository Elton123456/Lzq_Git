# MySQL 45-2

### 更新语句的执行过程

```mysql
mysql> create table T(ID int primary key, c int);
```

更新ID=2的整形字段c的值

```mysql
mysql> update T set c=c+1 where ID=2;
```

执行语句前连接数据库，是连接器的工作；

在一个表上有更新的时候，与该表相关的缓存会失效，所以这条更新语句会把表T缓存结果清空。

分析器和语法解析该语句为更新操作，优化器决定要使用的索引ID，然后执行器执行更新操作。

更新涉及两个重要的日志模块：redo（重做日志）和binlog（归档日志）。

`MySQL的WAL技术：Write-AheadLogging，关键点是先写日志，再写磁盘；`

当有记录需更新时，InnoDB引擎会先把记录写到redo log上，并更新内存。在适当时机，再将该操作记录更新到磁盘里面。

InnoDB（引擎层）特有的的redo log大小是固定的，可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，称为crash-safe。

Server层的日志为binlog（归档日志）。

redo log与binlog比较

| redo log                                                     |                            binlog                            |
| ------------------------------------------------------------ | :----------------------------------------------------------: |
| InnoDB引擎特有                                               |            MySQL的Server层实现，所有引擎均可使用             |
| 物理日志，记录“某个数据页做的修改”                           |   逻辑日志，记录该语句的原始逻辑，eg：给ID=2的c整形字段+1    |
| 空间固定会用完，所以循环写（用完时，将日志写入磁盘后，清除该部分日志） | 追加写，指文件写到一定大小时会切换到下一个，并不覆盖之前的日志 |

update语句执行流程：

取ID=2这一行-->__数据页在内存中? 返回行数据 : 磁盘中读入内存__-->将该行C值+1-->加入新行-->__新行更新到内存__-->__写入redolog，处于prepare阶段__-->写binlog-->__提交事务，处于commit状态__

注1：细体为执行器中执行；粗体为InnoDB内部执行

####  两阶段提交：最后三步将redo log拆成两个步骤，即prepare和commit

why？

an：可以使两份日志间的逻辑保持一致。

